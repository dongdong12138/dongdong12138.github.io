---
sidebar_position: 8
---

# 计算属性 & 监视

## computed 计算属性

```js title="函数形式"
import { computed } from 'vue'

let fullName = computed(() => {
  return person.firstName + '-' + person.lastName
})
```

```js title="对象形式"
import { computed } from 'vue'

let fullName = computed({
  get() {
    return person.firstName + '-' + person.lastName
  },
  set(value) {
    const nameArr = value.split('-')
    person.firstName = nameArr[0]
    person.lastName = nameArr[1]
  }
})
```

函数式写法无法修改计算属性的值，因为只有 getter 没有 setter。

## watch 监视

`watch` 函数接收三个参数：监听源、回调函数、配置对象（包含 `immediate`、`deep`）。

两个小“坑”：
- 监视 `reactive` 定义的响应式数据时，`oldValue` 无法正确获取，且强制开启了深度监视（`deep` 配置失效）；
- 监视 `reactive` 定义的响应式数据中的某个属性，且属性值不是基本数据类型：`deep` 配置有效。

### 监听 ref 数据

```js
import { ref, watch } from 'vue'

let sum = ref(0)
let msg = ref('hello')
let person = ref({ name: '张三', age: 18 })

// 监视一个
watch(sum, (newValue, oldValue) => {
  console.log('sum 变化了', newValue, oldValue)
}, { immediate: true })

// 监视多个
watch([sum, msg], (newValue, oldValue) => {
  console.log('sum 或 msg 变化了', newValue, oldValue)
})

// 监视 ref 定义的复杂类型的数据
//    开启深度监视，当对象中的属性发生变化时，就会触发 handler 函数
//    不开启深度监视，只有当对象本身（引用地址）发生变化时，才会触发 handler 函数
watch(person, (newVal, oldVal) => {
  console.log(newVal, oldVal)
}, { deep: true })

// 监视 ref 定义的复杂类型的数据中的属性
watch(person.value, (newVal, oldVal) => {
  console.log(newVal, oldVal)
})
```

:::caution

监视 `ref` 定义的基本类型的数据：
- 不用 `.value`，因为 `.value` 已经获取到具体的值了；
- `watch` 只能监视属性或变量的变化，而不能监视具体的值。

监视 `ref` 定义的复杂类型的数据：
- 如果监视的是整个对象是否发生变化（对象的引用地址是否发生变化），那就不用 `.value`；
- 如果监视的是对象中的某个属性：
    - 需要 `.value`，因为通过 `.value` 才能真正获取到源对象（此时监视的其实已经是 `reactive` 定义的数据了）；
    - 如果不使用 `.value`，可以开启深度监视。

:::

### 监视 reactive 数据

```ts
import { reactive, watch } from 'vue';

let person = reactive({
  name: '张三',
  age: 18,
  job: {
    j1: {
      salary: 20
    }
  }
});

// 若 watch 监视的是 reactive 定义的响应式数据，则无法正确获得 oldValue，且强制开启了深度监视
watch(person, (newValue, oldValue) => {
  console.log('person变化了', newValue, oldValue);
}, { immediate: true, deep: false });    // 此处的 deep 配置无效

// 监视 reactive 定义的响应式数据中的某个属性
watch(() => person.job, (newValue, oldValue) => {
  console.log('person的job变化了', newValue, oldValue);
}, { immediate: true, deep: true });

// 监视 reactive 定义的响应式数据中的多个属性
watch([() => person.job, () => person.name], (newValue, oldValue) => {
  console.log('person的job变化了', newValue, oldValue);
}, { immediate: true, deep: true });

// 如果监视的是对象（person）中的对象（job），那么就可以开启深度监视
watch(() => person.job, (newValue, oldValue) => {
  console.log('person的job变化了', newValue, oldValue);
}, { deep: true });    // 此处监视的是 reactive 定义的对象中的某个属性，所以 deep 配置有效
```

## watchEffect

### 基础使用

- `watch`：既要指明监视的属性，也要指明监视的回调；
- `watchEffect`：不用指明监视哪个属性，监视的回调中用到哪个属性，就监视哪个属性；
- `watchEffect`：一上来就默认调用一次，相当于设置了 `immediate: true`。

`watchEffect` 有点像 `computed`：
- 但 `computed` 注重的是计算出来的值（回调函数的返回值），所以必须要写返回值；
- 而 `watchEffect` 更注重的是过程（回调函数的函数体），所以不用写返回值。

```js
import { ref, reactive, watchEffect } from 'vue'

let sum = ref(0)
let person = reactive({ name: '张三', age: 18 })

// watchEffect 所指定的回调中用到的数据只要发生变化，则直接重新执行回调
// 初始化的时候也会执行一次回调
watchEffect(() => {   // 回调函数不接收 newValue、oldValue 参数
  const x1 = sum.value
  const x2 = person.age   // person.name 发生变化时，不触发回调
  console.log('watchEffect 配置的回调执行了')
})
```

### 清除副作用

```ts
import { watchEffect, ref } from 'vue';

let message = ref<string>('');
let message2 = ref<string>('');

watchEffect(oninvalidate => {
  console.log('message', message.value);
  // 触发监听之前会先调用这个函数
  oninvalidate(() => {

  });
  console.log('message2', message2.value);
});
```

### 停止监听

```ts
import { watchEffect, ref } from 'vue';

let message = ref<string>('');
let message2 = ref<string>('');

const stop = watchEffect(oninvalidate => {
  console.log('message', message.value);
  oninvalidate(() => {

  });
  console.log('message2', message2.value);
}, {
  // flush 可以设置侦听器执行时机
  //    pre：侦听器将在组件更新之前执行（默认）
  //    post：侦听器将在组件更新之后执行
  //    sync：同步触发
  flush: 'post',
  onTrigger() {   // 可以帮助我们调试 watchEffect
    debugger;
  }
});

// 调用 watchEffect 返回的函数，会停止监听
stop();
```
