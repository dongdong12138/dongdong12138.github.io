---
sidebar_position: 3
---

# Vue3 核心语法（一）

## OptionsAPI 与 CompositionAPI

Vue2 的 API 设计是 Options（配置）风格的，Vue3 的 API 设计是 Composition（组合）风格的。

Options API 的弊端：数据、方法、计算属性等，是分散在 `data`、`methods`、`computed` 中的，若想新增或者修改一个需求，就需要分别修改 `data`、`methods`、`computed`，不便于维护和复用。

Composition API 的优势：可以用函数的方式，更加优雅的组织代码，让相关功能的代码更加有序的组织在一起。

## 拉开序幕的 setup

### setup 概述

`setup` 是 `Vue3` 中一个新的配置项，值是一个函数，它是 `Composition API` **“表演的舞台”**，组件中所用到的数据、方法、计算属性、监视等等，均配置在 `setup` 中。

特点如下：

- `setup` 函数返回的对象中的内容，可直接在模板中使用
- `setup` 中访问 `this` 是 `undefined`
- `setup` 函数会在 `beforeCreate` 之前调用，它是“领先”所有钩子执行的

```html
<template>
  <div class="person">
    <h2>姓名：{{ name }}</h2>
    <h2>年龄：{{ age }}</h2>
    <button @click="changeName">修改名字</button>
    <button @click="changeAge">年龄+1</button>
    <button @click="showTel">点我查看联系方式</button>
  </div>
</template>

<script lang="ts">
  export default {
    name: 'Person',
    setup() {
      console.log(this)   // undefined

      // 数据，原来写在 data 中（此时的 name、age、tel 都不是响应式数据）
      let name = '张三'
      let age = 18
      let tel = '13888888888'

      // 方法，原来写在 methods 中
      function changeName() {
        name = 'zhang-san'  // 这么修改 name 页面是不变化的
        console.log(name)
      }
      function changeAge() {
        age += 1            // 这么修改 age 页面是不变化的
        console.log(age)
      }
      function showTel() {
        alert(tel)
      }

      // 返回一个对象，对象中的内容，模板中可以直接使用
      return { name, age, tel, changeName, changeAge, showTel }
    }
  }
</script>
```

### setup 的返回值

- 若返回一个**对象**：则对象中的属性、方法等，在模板中均可以直接使用
- 若返回一个**函数**：则可以自定义渲染内容，如：
    ```ts
    setup() {
      // 返回一个渲染函数
      return () => '你好啊！'
    }
    ```

### setup 与 Options API 的关系

- Options API 中**可以访问**到 `setup` 中的属性和方法，但 `setup` 中**不能访问**到 Options API 中的属性和方法
  - 因为在生命周期中 `setup` 是最先执行的，`setup` 
    执行完成后会把数据挂到 Vue 实例上，而 Options API 中的 `this` 指向的就是 Vue 实例，所以可以访问到
- 如果 Options API 与 `setup` 中的属性或方法有冲突，以 `setup` 为优先

### setup 语法糖

```html
<template>
  <div class="person">
    <h2>姓名：{{ name }}</h2>
    <h2>年龄：{{ age }}</h2>
    <button @click="changName">修改名字</button>
    <button @click="changAge">年龄+1</button>
    <button @click="showTel">点我查看联系方式</button>
  </div>
</template>

<script lang="ts">
  export default {
    name: 'Person',
  }
</script>

<!-- setup 语法糖 -->
<script setup lang="ts">
  console.log(this)   // undefined

  // 数据（此时的 name、age、tel 都不是响应式数据）
  let name = '张三'
  let age = 18
  let tel = '13888888888'

  // 方法
  function changName() {
    name = '李四'   // 这么修改 name 页面是不变化的
  }
  function changAge() {
    console.log(age)
    age += 1        // 这么修改 age 页面是不变化的
  }
  function showTel() {
    alert(tel)
  }
</script>
```

扩展：上述代码，还需要编写一个不写 `setup` 的 `script` 标签，去指定组件名字，比较麻烦，我们可以借助 `vite` 中的插件简化：

1. `npm i vite-plugin-vue-setup-extend -D`
2. `vite.config.ts`
    ```ts
    import { defineConfig } from 'vite'
    import vue from '@vitejs/plugin-vue'
    import VueSetupExtend from 'vite-plugin-vue-setup-extend'
    
    export default defineConfig({
      plugins: [vue(), VueSetupExtend()]
    })
    ```
3. `<script setup lang="ts" name="Person">`

:::tip

Vue3.3+ 提出了 `defineOptions` 函数，可以用来直接在 `<script setup>` 中声明组件选项，而不必使用单独的 `<script>` 块。

```html
<script setup>
defineOptions({
  name: 'Person'
})
</script>
```

:::

## ref 全家桶

### ref

- 作用：创建基本类型的响应式数据（变量）
- 语法：`let xxx = ref(初始值)`
- 返回值：一个 `RefImpl` 的实例对象，简称 `ref 对象` 或 `ref`，`ref` 对象的 **`value` 属性是响应式的**
- 注意点：
  - `JS` 中操作数据需要 `xxx.value`，但模板中不需要 `.value`，直接使用即可，因为模板中会自动“解包”
  - 对于 `let name = ref('张三')` 来说，`name` 不是响应式的，`name.value` 才是响应式的

```html
<template>
  <div class="person">
    <h2>姓名：{{ name }}</h2>
    <h2>年龄：{{ age }}</h2>
    <button @click="changeName">修改名字</button>
    <button @click="changeAge">年龄+1</button>
    <button @click="showTel">点我查看联系方式</button>
  </div>
</template>

<script setup lang="ts" name="Person">
import { ref } from 'vue'

// name 和 age 是一个 RefImpl 的实例对象，简称 ref 对象，它们的 value 属性是响应式的
let name = ref('张三')
let age = ref(18)
// tel 就是一个普通的字符串，不是响应式的
let tel = '13888888888'

function changeName() {
  // JS 中操作 ref 对象时候需要 .value
  name.value = '李四'
  console.log(name.value)

  // 注意：name 不是响应式的，name.value 才是响应式的，所以如下代码并不会引起页面的更新
  // name = ref('zhang-san')
}
function changeAge() {
  // JS 中操作 ref 对象时候需要 .value
  age.value += 1
  console.log(age.value)
}
function showTel() {
  alert(tel)
}
</script>
```

### isRef

用于判断一个值是不是一个 `ref` 对象。

```ts
import { ref, Ref, isRef } from 'vue';

let message1: Ref<string | number> = ref('Hello World');
let message2: number = 123;

const changeMsg = () => {
  message1.value = '你好世界';
  console.log(isRef(message1));  // true
  console.log(isRef(message2));  // false
};
```

### ref 控制台小妙招

在控制台查看输出的 `ref` 对象很不方便，可以点击控制台右上角的“设置”，勾选“启用自定义格式设置工具”。

![img_5.png](images/img_5.png)

![img_6.png](images/img_6.png)

刷新浏览器，现在控制台输出的值就很明了。

![img_7.png](images/img_7.png)

### shallowRef

“浅”的 `ref` 响应式对象，只有 `.value` 属性是响应式的，`.value` 中的值不是响应式的。

```html
<script setup lang="ts">
import { Ref, shallowRef } from 'vue'

interface Obj {
  name: string
}

const person: Ref<Obj> = shallowRef({
  name: '张三'
})
const changePerson = () => {
  // 无法对 name 属性进行修改，因为用的是 shallowRef，name 属性没有响应式
  // person.value.name = '李四'
  
  // 但可以对 .value 进行修改，因为 .value 是响应式的
  person.value = { name: '李四' }
}
</script>

<template>
  <div>{{ person }}</div>
  <button @click="changePerson">changePerson</button>
</template>
```

`shallowRef()` 常用于对大型数据结构的性能优化，减少大型不可变结构的响应性开销。

### triggerRef

对于 `shallowRef`，修改 `.value` 中的值不会引起页面更新，因为它不是响应式的。但可以使用 `triggerRef` 进行强制更新。

```html
<script setup lang="ts">
import { Ref, shallowRef, triggerRef } from 'vue'

interface Obj {
  name: string
}

const person: Ref<Obj> = shallowRef({
  name: '张三'
})
const changePerson = () => {
  // name 属性的值在内存中被修改了，但是无法对视图进行更新，因为用的是 shallowRef，name 属性没有响应式
  person.value.name = '李四'
  // 在对 person 进行修改后，使用 triggerRef，可以强制更新 person
  triggerRef(person)
}
</script>

<template>
  <div>{{ person }}</div>
  <button @click="changePerson">changePerson</button>
</template>
```

### 注意事项

同时修改 `shallowRef()` 与 `ref()` 定义的数据，`shallowRef` 的数据也会改变。

```ts
import { ref, shallowRef } from 'vue';

const p1 = ref({ name: '张三' });
const p2 = shallowRef({ name: '李四' });

const handleChange = () => {
  p1.value.name = '张三123';
  // p2 的 name 本来是改不了的，因为它是 shallowRef 定义的
  // 但由于这个方法中也修改了 p1，p1 是 ref 定义的，ref 底层是调用 triggerRef 更新视图的
  // 所以 p2 也被一起修改了
  p2.value.name = '李四123';
};
```

### customRef

用于创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。

`customRef` 是一个函数，接受 track（跟踪）、trigger（触发）作为参数，返回一个包含 getter、setter 的对象。

```html title="实现防抖效果"
<script setup lang="ts">
import { customRef } from 'vue'

// 自定义 myRef
function myRef<T, K>(value: T, delay: K) {
  let timer
  // 通过 customRef 去实现自定义
  return customRef((track, trigger) => {
    return {
      get() {
        track()   // 告诉 Vue 这个 value 值是需要被“追踪”的
        return value
      },
      set(newValue) {
        clearTimeout(timer)
        timer = setTimeout(() => {
          value = newValue
          trigger()   // 告诉 Vue 去更新界面
        }, delay)
      }
    }
  })
}

let keyword = myRef('hello', 500)
</script>

<template>
  <input v-model="keyword" type="text">
  <h3>{{ keyword }}</h3>
</template>
```

### ref 标识

```html
<script setup lang="ts">
import { ref } from 'vue';

// 变量名必须与模板中的 ref 的值保持一致
// ref 也可以接受一个泛型，否则会被推断为 any
const divEle = ref<HTMLDivElement>();

const handleChange = () => {
  // 也要通过 .value 获取 DOM 元素
  console.log(divEle.value.innerText);
};
</script>

<template>
  <!-- 使用 ref 给元素打“标识” -->
  <div ref="divEle">123</div>
  <button @click="handleChange">change</button>
</template>
```

