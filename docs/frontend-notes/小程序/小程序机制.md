---
sidebar_position: 1
---

# 小程序机制

## 什么是小程序

小程序页面本质上还是网页，开发用的还是 HTML、CSS、JS，但小程序不支持浏览器 API，只能用宿主环境（如微信、支付宝、淘宝等）提供的 API。
 
## 微信小程序框架介绍

### 双线程模型

客户端原生技术与 Web 技术相结合的混合技术，简称 Hybrid。

在 Web 中，UI 渲染和脚本执行都在一个单线程中执行，这就容易导致一些逻辑任务抢占 UI 渲染的资源；而小程序采用客户端与 Web 两者结合起来的 Hybrid 技术来渲染小程序。

小程序的渲染层与逻辑层分别由两个线程管理（双线程模型）：
- 逻辑层：创建一个单独的线程（JsCore 线程）去执行 JS 脚本，在这里执行的都是有关小程序业务逻辑的代码，负责逻辑处理、数据请求、接口调用等
- 视图层：页面渲染相关的任务全都在 WebView 线程里执行，通过逻辑层的代码去控制渲染哪些页面（一个小程序存在多个界面，所以视图层存在多个 WebView 线程）

![img.png](img.png)

JSBridge 起到架起上层开发与 Native（系统层）的桥梁的作用，使得小程序可通过 API 使用原生的功能，且部分组件为原生组件实现，从而有良好体验与性能。

![img_1.png](img_1.png)

设计目的：为了管控和安全等问题，阻止开发者使用一些例如浏览器的 window 对象跳转页面、操作 DOM、执行一些开放性接口等。

### 数据驱动视图变化

问题：JS 逻辑代码放到单独的线程去运行，在 Webview 线程里没法直接操作 DOM，开发者如何实现动态更改界面呢？

DOM 的更新通过逻辑层与渲染层的数据通信来实现：

1. 在渲染层把 WXML 转化成对应的 JS 对象
2. 在逻辑层发生数据变更的时候，通过宿主环境提供的 `setData` 方法把数据从逻辑层传递到 Native（微信客户端），再由 Native 转发到渲染层
   - 逻辑层和视图层的通信由 Native 做中转，逻辑层发送网络请求也是由 Native 做转发
3. 对比数据的前后差异，把差异应用在原来的 DOM 树上，更新界面
   - JS 对象模拟 DOM 树 -> 比较两棵虚拟 DOM 树的差异 -> 把差异应用到真实 DOM 树上

![img_2.png](img_2.png)

### 事件的处理

由于视图层只进行渲染，当视图层发生交互，交互事件会被 Native 拦截，由 Native 做中转，将事件的回调传递给逻辑层。

![img_3.png](img_3.png)

### 运行机制和更新机制

![img_4.png](img_4.png)

**运行机制（启动机制）**
- 冷启动：用户首次打开小程序或小程序被微信主动销毁后再次打开时，小程序需要重新加载启动
- 热启动：如果用户已经打开过小程序，并在一定时间内再次打开该小程序，则无需重新启动，只需将小程序从后台切换到前台

**更新机制**
- 启动时同步更新：
   - 定期检查小程序版本：微信会定期检查最近使用的小程序是否有更新，如果有更新，下次小程序启动时会同步进行更新，更新到最新版本后再打开小程序
   - 长时间未使用小程序：用户长时间未使用小程序时，会强制同步检查版本更新，更新到最新版本后再打开小程序
- 启动时异步更新：打开小程序发现有新版本，先异步下载，下次冷启动时加载新版本
- 开发者手动调用 `wx.getlpdateManager` API 进行更新
- 小程序管理后台可以设置“优先使用本地版本”和“小程序最低可用版本”

**注意**
- 当小程序进入后台，客户端会维持一段时间的运行，超过一定时间后（目前是 5 分钟）会被微信主动销毁
- 当短时间内（5s）连续两次以上收到系统内存告警，也会进行小程序的销毁

![img_5.png](img_5.png)

## 微信小程序基本内容

### 基础核心

**代码注入**

- 按需注入：`"lazyCodeLoading": "requiredComponents"`，小程序仅注入当前页面需要的自定义组件和页面代码，在页面中不会用到的自定义组件不会被加载和初始化
- 用时注入：在开启“按需注入”的前提下，指定一部分自定义组件不在小程序启动时注入，而是在真正渲染的时候才进行注入，使用占位组件在需要渲染但注入完成前展示

**分包加载**

原则：
- 声明 `subpackages` 后，将按照 `subpackages` 配置的路径进行打包，`subpackages` 配置路径以外的目录将被打包到 app（主包）中
- app（主包）也可以有自己的 pages（即最外层的 pages 字段）
- `subpackage` 的根目录不能是另外一个 `subpackage` 内的子目录
- tabBar 页面必须在 app（主包）内

独立分包：
- 开发者可以按需将一些页面配置到独立分包中，当小程序从普通的分包页面启动时，需要首先下载主包
- 独立分包运行时，App 并不一定会被注册，因此 `getApp()` 也不一定可以获得 App 对象，基础库 2.2.4 版本开始 `getApp` 支持 `allowDefault` 参数，在 App 未定义时返回一个默认实现。当主包加载，App 被注册时，默认实现中定义的属性会被覆盖合并到真正的 App 中

**小程序如何调试**

- vconsole
- sourceMap
- 实时日志：重写 log，使用 `wx.getRealtimeLogManager` 封装，在运营后台“【开发】->【开发管理】->【运维中心】->【实时日志】”查看
- errno：针对 API 的 callback err 进行状态码的判断，便于针对业务场景语义化展示

**小程序如何兼容版本**

- 版本号比较

   ```js
   const version = wx.getSystemInfoSync().SDKVersion
   
   if (compareVersion(version, '1.1.0') >= 0) {
      wx.openBluetoothAdapter()
   } else {
   // 如果希望用户在最新版本的客户端上体验您的小程序，可以这样子提示
      wx.showModal({
         title: '提示',
         content: '当前微信版本过低，无法使用该功能，请升级到最新微信版本后重试。'
      })
   }
   ```

- 检查 API 是否存在

   ```js
   if (wx.openBluetoothAdapter) {
      wx.openBluetoothAdapter()
   } else {
   // 如果希望用户在最新版本的客户端上体验您的小程序，可以这样子提示
      wx.showModal({
         title: '提示',
         content: '当前微信版本过低，无法使用该功能，请升级到最新微信版本后重试。'
      })
   }
   ```

- 使用 `wx.canIUse`

   ```js
   wx.showModal({
      success: function (res) {
         if (wx.canIUse('showModal.success.cancel')) {
            console.log(res.cancel)
         }
      }
   })
   ```

- 运营后台设置最低基础库版本

### 框架

### 组件

### API

### 面试常见问题
